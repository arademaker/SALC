
fmod ALC-SYNTAX is 
 sorts AConcept Concept ARole Role .
 subsort AConcept < Concept .
 subsort ARole < Role .

 ops ALL EXIST : Role Concept -> Concept .
 ops CTRUE CFALSE : -> Concept .
 op _&_ : Concept Concept -> Concept [gather (e E) prec 31] .
 op _|_ : Concept Concept -> Concept [gather (e E) prec 32] .
 op ~_  : Concept -> Concept [prec 30] .
endfm

fmod LABEL is 
 inc ALC-SYNTAX .

 sort Label .
 subsort Role < Label .
endfm

view Label from TRIV to LABEL is 
 sort Elt to Label .
endv

fmod LALC-SYNTAX is 
 inc LABEL .
 inc LIST{Label} .

 op s : Role List{Label} -> Label .

 vars R : Role .
 eq s(R, nil) = R .

 sorts Expression LConcept FzConcept .
 subsorts LConcept FzConcept < Expression .

 op <_|_|_> : List{Label} Concept List{Label} -> LConcept [ctor] . 
 
 op [_,_] : Nat LConcept -> FzConcept .
endfm


fmod LALC-AUX is 
 inc LALC-SYNTAX .
 
 sort LabelTuple .
 op [_,_] : List{Label} List{Label} -> LabelTuple [ctor] .

 op join   : List{Label} List{Label} Concept -> Concept .
 op invert : Concept -> Concept .
 op split  : List{Label} List{Label} Concept -> LabelTuple .
 op neg : List{Label} List{Label} -> LabelTuple .
 
 vars L1 L2 L : List{Label} .
 vars R S : Role .
 vars C : Concept .
 
 eq neg(L1, L2) = split(nil, nil, invert(join(L1, L2, CTRUE))) .

 eq join(L1,  s(R,L1) L2, C)   = join(L1, L2, EXIST(R,C)) .  
 eq join(nil, R L2, C)   = join(nil, L2, EXIST(R,C)) . 
 
 eq join(L1 R, L2, C) = join(L1, L2, ALL(R,C)) [owise] . 
 eq join(nil, nil, C) = C .
 
 eq invert(ALL(R, C))   = EXIST(R, invert(C)) .
 eq invert(EXIST(R, C)) = ALL(R, invert(C)) .
 eq invert(C) = C [owise] .
 
 eq split(L1, L2, ALL(R,C))   = split(L1 R, L2, C) .
 eq split(L1, L2, EXIST(R,C)) = split(L1, s(R,L1) L2, C) .
 eq split(L1, L2, C) = [L1, L2] [owise] .
 
endfm

