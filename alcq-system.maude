

fmod SYNTAX is 
 inc NAT .

 sorts AConcept Concept ARole Role .
 subsort AConcept < Concept .
 subsort ARole < Role .

 ops ALL EXIST : Role Concept -> Concept .
 ops CTRUE CFALSE : -> AConcept .
 op _&_ : Concept Concept -> Concept [gather (e E) prec 31] .
 op _|_ : Concept Concept -> Concept [gather (e E) prec 32] .
 op ~_  : Concept -> Concept [prec 30] .

 eq ~ CTRUE = CFALSE .
 eq ~ CFALSE = CTRUE .

 ops AT-MOST AT-LEAST : Nat Role Concept -> Concept .
 op INV : Role -> Role .

 var R : Role .
 var C : Concept .

 --- eq AT-LEAST(1, R, C) = EXIST(R, C) .
endfm


fmod LABEL is 
 inc SYNTAX .

 sort Label .
 subsort Role < Label .
endfm


view Label from TRIV to LABEL is 
 sort Elt to Label .
endv


fmod LALC-SYNTAX is 
 inc LABEL .
 inc LIST{Label} .

 sort SLabel .
 subsort SLabel < Label .

 op s : Label List{Label} -> SLabel .

 vars L1 L2 L : List{Label} .
 vars R S : Role .
 vars C : Concept .

 eq s(R, nil) = R .

 sorts Expression LConcept FzConcept .
 subsorts LConcept FzConcept < Expression .

 op <_|_|_> : List{Label} Concept List{Label} -> LConcept [ctor] . 
 
 op [_,_] : Nat LConcept -> FzConcept .

 
 sort LabelTuple .

 op [_,_] : List{Label} List{Label} -> LabelTuple [ctor] .

 op join   : List{Label} List{Label} Concept -> Concept .
 op invert : Concept -> Concept .
 op split  : List{Label} List{Label} Concept -> LabelTuple .
 op neg : List{Label} List{Label} -> LabelTuple .
 
 eq neg(L1, L2) = split(nil, nil, invert(join(L1, L2, CTRUE))) .

 eq join(L1,  s(R,L1) L2, C)   = join(L1, L2, EXIST(R,C)) .  
 eq join(nil, R L2, C)   = join(nil, L2, EXIST(R,C)) . 
 
 eq join(L1 R, L2, C) = join(L1, L2, ALL(R,C)) [owise] . 
 eq join(nil, nil, C) = C .
 
 eq invert(ALL(R, C))   = EXIST(R, invert(C)) .
 eq invert(EXIST(R, C)) = ALL(R, invert(C)) .
 eq invert(C) = C [owise] .
 
 eq split(L1, L2, ALL(R,C))   = split(L1 R, L2, C) .
 eq split(L1, L2, EXIST(R,C)) = split(L1, s(R,L1) L2, C) .
 eq split(L1, L2, C) = [L1, L2] [owise] .
 
endfm


view Expression from TRIV to LALC-SYNTAX is 
 sort Elt to Expression .
endv


fmod LALCQI-SYNTAX is 
 inc LALC-SYNTAX .

 sort QLabel .
 subsort QLabel < Label .

 ops gt lt : Nat Label -> QLabel .

endfm


fmod SEQUENT-CALCULUS is
 inc LALC-SYNTAX .
 inc SET{Expression} .
 inc SET{Label} .
 inc SET{Nat} .
 inc NAT . 
 inc QID .

 sort Sequent .

 sorts Goal State Proof .
 subsort Goal State < Proof .

 op next  : Nat -> State .
 op goals : Set{Nat} -> State .

 op [_from_by_is_] : Nat Nat Qid Sequent -> Goal [format (n d d d d d d d d d)] .
 op nil : -> Proof [ctor] .
 op __ : Proof Proof -> Proof [ctor comm assoc] .

 op _|-_ : Set{Expression} Set{Expression} -> Sequent [ctor prec 122 gather(e e)] .
 op _:_|-_:_ : Set{Expression} Set{Expression} Set{Expression} Set{Expression} -> Sequent [ctor prec 122 gather(e e e e)] .
 
endfm 



mod LALCQ-SYSTEM is 
 inc SEQUENT-CALCULUS .
 inc LALCQI-SYNTAX .
 inc INT .

 vars ALFA GAMMA : Set{Expression} .
 vars X Y N M : Nat .
 var XS : Set{Nat} .
 vars A B C D : Concept .
 vars R S : Role .
 var E : Expression .
 var AT : AConcept .
 var Q : Qid .
 vars L L1 L2 L3 L4 : List{Label} .

 --- 1. opera nas mais externas ou mais internas?
 --- 2. usar lista a direita pode ser melhor, caso contrario tenho que
 ---    garantir que nao existe existencial mais externo
 --- 3. como lidar com regras nao deterministicas? m > n sss inc em um, controle de aplicacoes
 --- 4. new provisos in ALC system rules. Note that we moved R_n and R^n for the right list!! 

 rl [initial] : 
   [ X from Y by Q is ALFA, < nil | AT | nil > |- < nil | AT | nil >, GAMMA ] goals((X, XS))  => 
   [ X from Y by Q is ALFA, < nil | AT | nil > |- < nil | AT | nil >, GAMMA ] goals((XS))  .

 crl [initial] : 
   [ X from Y by Q is ALFA, < L1 | A | L2 lt(n,R) > |- < L1 | A | L2 lt(m,R) >, GAMMA ] goals((X, XS))  => 
   [ X from Y by Q is ALFA, < L1 | A | L2 lt(n,R) > |- < L2 | A | L2 lt(m,R) >, GAMMA ] goals((XS)) 
  if n <= m .

 crl [initial] : 
   [ X from Y by Q is ALFA, < L1 | A | L2 gt(n,R) > |- < L1 | A | L2 gt(m,R) >, GAMMA ] goals((X, XS))  => 
   [ X from Y by Q is ALFA, < L1 | A | L2 gt(n,R) > |- < L2 | A | L2 gt(m,R) >, GAMMA ] goals((XS)) 
  if m <= n .


 rl [weak-l] : 
  [ X from Y by Q is      ALFA, E |- GAMMA ] next(N) goals((X, XS)) => 
  [ X from Y by Q is      ALFA, E |- GAMMA ] next(N + 1) goals((XS, N)) 
  [ N from X by 'weak-l is ALFA |- GAMMA ] .

 rl [weak-r] : 
  [ X from Y by Q is      ALFA |- GAMMA, E ] next(N) goals((X, XS)) => 
  [ X from Y by Q is      ALFA |- GAMMA, E ] next(N + 1) goals((XS, N)) 
  [ N from X by 'weak-r is ALFA |- GAMMA ] .
  

 op has-quant : List{Label} -> Bool .

 var T : Label .

 ceq has-quant(T L) = true 
  if (T :: QLabel) .

 eq has-quant(T L) = has-quant(L) [owise] .
 eq has-quant(nil) = false .

 crl [neg-l] : 
   [ X from Y by Q is    ALFA, < L1 | ~ A | L2 >  |- GAMMA ] next(N)  goals((X, XS)) => 
   [ X from Y by Q is    ALFA, < L1 | ~ A | L2 >  |- GAMMA ] next(N + 1) goals((XS, N))
   [ N from X by 'neg-l is ALFA |- GAMMA, < L3 | A | L4 > ] 
  if [L3, L4] := neg(L1, L2) /\ 
     not has-quant(L1 L2) .

 crl [neg-r] : 
   [ X from Y by Q is    ALFA |- GAMMA, < L1 | ~ A | L2 > ] next(N) goals((X, XS)) => 
   [ X from Y by Q is    ALFA |- GAMMA, < L1 | ~ A | L2 > ] next(N + 1) goals((XS, N))
   [ N from X by 'neg-r is ALFA, < L3 | A | L4 > |- GAMMA ] 
  if [L3, L4] := neg(L1, L2) /\
     not has-quant(L1 L2) .

 rl [least-l] : 
   [ X from Y by Q is  ALFA, < L1 | AT-LEAST(M, R, A) | L2 > |- GAMMA ] next(N) goals((X, XS)) => 
   [ X from Y by Q is  ALFA, < L1 | AT-LEAST(M, R, A) | L2 > |- GAMMA ] next(N + 1) goals((XS, N)) 
   [ N from X by 'least-l is  ALFA, < L1 | A | gt(M,R) L2 > |- GAMMA ] .

 rl [least-r] : 
   [ X from Y by Q is  ALFA |- < L1 | AT-LEAST(M, R, A) | L2 >, GAMMA ] next(N) goals((X, XS)) => 
   [ X from Y by Q is  ALFA |- < L1 | AT-LEAST(M, R, A) | L2 >, GAMMA ] next(N + 1) goals((XS, N)) 
   [ N from X by 'least-r is  ALFA |- < L1 | A | gt(M,R) L2 >, GAMMA ] .

 rl [most-l] : 
   [ X from Y by Q is  ALFA, < L1 | AT-MOST(M, R, A) | L2 > |- GAMMA ] next(N) goals((X, XS)) => 
   [ X from Y by Q is  ALFA, < L1 | AT-MOST(M, R, A) | L2 > |- GAMMA ] next(N + 1) goals((XS, N)) 
   [ N from X by 'most-l is  ALFA, < L1 | A | lt(M,R) L2 > |- GAMMA ] .

 rl [most-r] : 
   [ X from Y by Q is  ALFA |- < L1 | AT-MOST(M, R, A) | L2 >, GAMMA ] next(N) goals((X, XS)) => 
   [ X from Y by Q is  ALFA |- < L1 | AT-MOST(M, R, A) | L2 >, GAMMA ] next(N + 1) goals((XS, N)) 
   [ N from X by 'most-r is  ALFA |- < L1 | A | lt(M,R) L2 >, GAMMA ] .


 rl [quant-exist-l] : 
   [ X from Y by Q is  ALFA, < L1 | A | L2 R > |- GAMMA ] next(N) goals((X, XS)) => 
   [ X from Y by Q is  ALFA, < L1 | A | L2 R > |- GAMMA ] next(N + 1) goals((XS, N)) 
   [ N from X by 'quant-exist-l is  ALFA, < L1 | A | L2 gt(1,R) > |- GAMMA ] .

 rl [exist-quant-r] : 
   [ X from Y by Q is  ALFA |- < L1 | A | L2 gt(1,R) >, GAMMA ] next(N) goals((X, XS)) => 
   [ X from Y by Q is  ALFA |- < L1 | A | L2 gt(1,R) >, GAMMA ] next(N + 1) goals((XS, N)) 
   [ N from X by 'exist-quant-r is  ALFA |- < L1 | A | L2 R >, GAMMA ] .

 --- where g(1,R) in the two rules below could be g(n,R) for n >= 1

 rl [quant-exist-r] : 
   [ X from Y by Q is  ALFA |- < L1 | A | L2 R >, GAMMA ] next(N) goals((X, XS)) => 
   [ X from Y by Q is  ALFA |- < L1 | A | L2 R >, GAMMA ] next(N + 1) goals((XS, N)) 
   [ N from X by 'quant-exist-r is  ALFA |- < L1 | A | L2 gt(1,R) >, GAMMA ] .

 rl [exist-quant-l] : 
   [ X from Y by Q is  ALFA, < L1 | A | L2 gt(1,R) > |- GAMMA ] next(N) goals((X, XS)) => 
   [ X from Y by Q is  ALFA, < L1 | A | L2 gt(1,R) > |- GAMMA ] next(N + 1) goals((XS, N)) 
   [ N from X by 'exist-quant-l is  ALFA, < L1 | A | L2 R > |- GAMMA ] .

 vars m n : Nat .

 crl [quant-gt-l] : 
   [ X from Y by Q is  ALFA, < L1 | A | L2 gt(m,R) > |- GAMMA ] next(N) goals((X, XS)) => 
   [ X from Y by Q is  ALFA, < L1 | A | L2 gt(m,R) > |- GAMMA ] next(N + 1) goals((XS, N)) 
   [ N from X by 'quant-qt-r is  ALFA, < L1 | A | L2 gt((m - 1), R) > |- GAMMA ] 
  if m > 1 .

 rl [quant-gt-r] : 
   [ X from Y by Q is  ALFA |- < L1 | A | L2 gt(m,R) >, GAMMA ] next(N) goals((X, XS)) => 
   [ X from Y by Q is  ALFA |- < L1 | A | L2 gt(m,R) >, GAMMA ] next(N + 1) goals((XS, N)) 
   [ N from X by 'quant-qt-r is  ALFA |- < L1 | A | L2 gt((m + 1), R) >, GAMMA ] .

 rl [quant-lt-l] : 
   [ X from Y by Q is  ALFA, < L1 | A | L2 lt(m,R) > |- GAMMA ] next(N) goals((X, XS)) => 
   [ X from Y by Q is  ALFA, < L1 | A | L2 lt(m,R) > |- GAMMA ] next(N + 1) goals((XS, N)) 
   [ N from X by 'quant-lt-r is  ALFA, < L1 | A | L2 gt((m + 1), R) > |- GAMMA ] .

 crl [quant-lt-r] : 
   [ X from Y by Q is  ALFA |- < L1 | A | L2 lt(m,R) >, GAMMA ] next(N) goals((X, XS)) => 
   [ X from Y by Q is  ALFA |- < L1 | A | L2 lt(m,R) >, GAMMA ] next(N + 1) goals((XS, N)) 
   [ N from X by 'quant-lt-r is  ALFA |- < L1 | A | L2 lt((m - 1), R) >, GAMMA ] 
  if m > 1 .

endm
