fmod ALC-SYNTAX is 
 sorts AConcept Concept ARole Role .
 subsort AConcept < Concept .
 subsort ARole < Role .

 ops ALL EXIST : Role Concept -> Concept .
 ops CTRUE CFALSE : -> Concept .
 op _&_ : Concept Concept -> Concept [gather (e E) prec 31] .
 op _|_ : Concept Concept -> Concept [gather (e E) prec 32] .
 op ~_  : Concept -> Concept [prec 30] .
endfm
fmod LABEL is 
 inc ALC-SYNTAX .

 sort Label .
 sort LabelType .
 ops AL EX : -> LabelType [ctor] .

 op ((_,_)) : LabelType ARole -> Label [ctor] .
endfm

view Label from TRIV to LABEL is 
 sort Elt to Label .
endv
fmod LALC-SYNTAX is 
 inc LABEL .
 inc LIST{Label} .

 sort LConcept .
 op lc : List{Label} Concept -> LConcept [ctor] . 

 sorts AllList ExistList .
 subsorts List{Label} < AllList ExistList .
 
 var R : ARole .
 vars L L1 : List{Label} .
 var LB : Label .

 ops is-all is-exist : List{Label} -> Bool .
 eq is-all((AL, R) L) = is-all(L) .
 eq is-all((EX, R) L) = false .
 eq is-all(nil) = true [owise] .

 eq is-exist((EX, R) L) = is-exist(L) .
 eq is-exist((AL, R) L) = false .
 eq is-exist(nil) = true [owise] .

 op neg-list : List{Label} -> List{Label} .
 eq neg-list((AL, R) L) = (EX, R) neg-list(L) .
 eq neg-list((EX, R) L) = (AL, R) neg-list(L) .
 eq neg-list(nil) = nil [owise] .
endfm
view LConcept from TRIV to LALC-SYNTAX is 
 sort Elt to LConcept .
endv

mod SEQUENT-CALCULUS is
 inc LALC-SYNTAX .
 inc SET{LConcept} .
 inc SET{Nat} .
 inc NAT . 
 inc QID .

 sort Sequent .
 op _|-_ : Set{LConcept} Set{LConcept} -> Sequent [ctor prec 122 gather(e e)] .

 sorts Goal State Proof .
 subsort Goal State < Proof .

 op goals : Set{Nat} -> State .
 op next  : Nat -> State .

 op [_from_by_is_] : Nat Nat Qid Sequent -> Goal [format (n d d d d d d d d d)] .
 op __ : Proof Proof -> Proof [ctor comm assoc] .

 vars ALFA GAMMA : Set{LConcept} .
 vars X Y N : Nat .
 var XS : Set{Nat} .
 vars A B C D : Concept .
 vars R S : Role .
 var R1 : Qid .
 vars L L1 L2 : List{Label} .

 rl [initial] : 
  [ X from Y by R1 is ALFA, lc(L, A) |- lc(L, A), GAMMA ] goals((X, XS)) => 
  [ X from Y by R1 is ALFA, lc(L, A) |- lc(L, A), GAMMA ] goals(XS) .

 crl [and-r] : 
  [ X from Y by R1 is     ALFA |- GAMMA, lc(L, A & B) ] next(N) goals((X, XS)) => 
  [ X from Y by R1 is     ALFA |- GAMMA, lc(L, A & B) ] next(N + 2) goals((XS, N, N + 1))
  [ N from X by 'and-r is ALFA |- GAMMA, lc(L, A) ] 
  [ N + 1 from X by 'and-r is ALFA |- GAMMA, lc(L, B) ] if is-all(L) . 

 crl [and-l] : 
  [ X from Y by R1 is     ALFA, lc(L, A & B)       |- GAMMA ] next(N) goals((X, XS)) => 
  [ X from Y by R1 is     ALFA, lc(L, A & B)       |- GAMMA ] next(N + 1) goals((XS, N))
  [ N from X by 'and-l is ALFA, lc(L, A), lc(L, B) |- GAMMA ] if is-all(L) .

 crl [or-l] : 
  [ X from Y by R1 is    ALFA, lc(L, A | B) |- GAMMA ] next(N) goals((X, XS)) =>
  [ X from Y by R1 is    ALFA, lc(L, A | B) |- GAMMA ] next(N + 2) goals((XS, N, N + 1))
  [ N from X by 'or-l is ALFA, lc(L, A)  |- GAMMA ] 
  [ N + 1 from X by 'or-l is ALFA, lc(L, B)  |- GAMMA ] if is-exist(L) . 

 crl [or-r] : 
  [ X from Y by R1 is    ALFA |- GAMMA, lc(L, A | B) ] next(N) goals((X, XS)) => 
  [ X from Y by R1 is    ALFA |- GAMMA, lc(L, A | B) ] next(N + 1) goals((XS, N))
  [ N from X by 'or-r is ALFA |- GAMMA, lc(L, A), lc(L, B) ] if is-exist(L) .

 rl [forall-r] : 
  [ X from Y by R1 is        ALFA |- GAMMA, lc(L, ALL(R, A)) ] next(N) goals((X, XS)) => 
  [ X from Y by R1 is        ALFA |- GAMMA, lc(L, ALL(R, A)) ] next(N + 1) goals((XS, N))
  [ N from X by 'forall-r is ALFA |- GAMMA, lc(L (AL,R), A)  ] .

 rl [forall-l] : 
  [ X from Y by R1 is        ALFA, lc(L, ALL(R, A)) |- GAMMA ] next(N) goals((X, XS)) => 
  [ X from Y by R1 is        ALFA, lc(L, ALL(R, A)) |- GAMMA ] next(N + 1) goals((XS, N))
  [ N from X by 'forall-l is ALFA, lc(L (AL,R), A)  |- GAMMA ] .

 rl [exist-r] : 
  [ X from Y by R1 is       ALFA |- GAMMA, lc(L, EXIST(R, A)) ] next(N) goals((X, XS)) => 
  [ X from Y by R1 is       ALFA |- GAMMA, lc(L, EXIST(R, A)) ] next(N + 1) goals((XS, N))
  [ N from X by 'exist-r is ALFA |- GAMMA, lc(L (EX, R), A)   ] .

 rl [exist-l] : 
  [ X from Y by R1 is       ALFA, lc(L, EXIST(R, A)) |- GAMMA ] next(N) goals((X, XS)) => 
  [ X from Y by R1 is       ALFA, lc(L, EXIST(R, A)) |- GAMMA ] next(N + 1) goals((XS, N))
  [ N from X by 'exist-l is ALFA, lc(L (EX, R), A)   |- GAMMA ] .

 rl [neg-l] : 
  [ X from Y by R1 is     ALFA, lc(L, ~ A) |- GAMMA ] next(N) goals((X, XS)) => 
  [ X from Y by R1 is     ALFA, lc(L, ~ A) |- GAMMA ] next(N + 1) goals((XS, N))
  [ N from X by 'neg-l is ALFA |- GAMMA, lc(neg-list(L), A) ] .

 rl [neg-r] : 
  [ X from Y by R1 is     ALFA |- GAMMA, lc(L, ~ A) ] next(N) goals((X, XS)) => 
  [ X from Y by R1 is     ALFA |- GAMMA, lc(L, ~ A) ] next(N + 1) goals((XS, N))
  [ N from X by 'neg-r is ALFA, lc(neg-list(L), A) |- GAMMA ] .

endm
mod TESTE is
 inc SEQUENT-CALCULUS .

 ops A B C D E : -> AConcept .
 ops R S T U V : -> ARole .

 ops seq1 seq2 : -> Sequent .
 eq seq1 = lc(nil, ALL(R, ~ (A & B))) |- lc(nil, ALL(R, ~ (A | B))) .
 eq seq2 = lc(nil, ALL(R, A | B)), lc(nil, ALL(S, A | B)) |- lc(nil, EXIST(R, A & B)), lc(nil, EXIST(S, A & B)) .

 ops init1 init2 : -> Goal .
 eq init1 = [ 0 from 0 by 'init is seq1 ] next(1) goals(0) .
 eq init2 = [ 0 from 0 by 'init is seq2 ] next(1) goals(0) .
endm

--- set show command off .
--- rew init .

search init1 =>! P:Proof .

eof

mod TESTE is
 inc SEQUENT-CALCULUS .

 subsorts AConcept ARole < Qid .
endm
