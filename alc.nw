\documentclass{article}

\usepackage[margin=2cm]{geometry}
\usepackage{noweb}
\input{../macros.tex}

\begin{document}

\title{A naive implementation of a Sequent Calculus for $\mathcal{ALC}$ in Maude}
\author{Alexandre Rademaker}
\maketitle

\begin{abstract} 
  This is an exercise about how could be an implementation of a
  sequent calculos in Maude. Maude most used features here are pattern
  matching for definition of functions, data and program as terms, the
  easy way to implement ``possible proofs'' using rules, search and
  rewrites.
\end{abstract}


\section{Introduction}

The main motivation to implement the system described here is my need
to exercise the deduction system $S_{\mathcal{ALC}}$.

\section{The Implementation}

\subsection{The language}

The first step was to implement the language. If I was thinking about
a generic theorem prover, I would have started from the common
infrastructure for a sequent calculus reasoner. However, since my
purpose was to archive my results quickly, I choose to start from the
language definition.

<<alc-language.maude>>=
fmod ALC-SYNTAX is 
 sorts AConcept Concept ARole Role .
 subsort AConcept < Concept .
 subsort ARole < Role .

 ops ALL EXIST : Role Concept -> Concept .
 ops CTRUE CFALSE : -> Concept .
 op _&_ : Concept Concept -> Concept [gather (e E) prec 31] .
 op _|_ : Concept Concept -> Concept [gather (e E) prec 32] .
 op ~_  : Concept -> Concept [prec 30] .
endfm

@ 

The system is a labeled sequent calculus. So that, we had actually to
deal with two different languages. The first one, the traditional
$\mathcal{ALC}$. The second one, the extended syntax to labels. Since
Maude as developed for formal analysis and verification, based in a
well studied formalism called Rewriting Logic, its support for modular
specification is more formal and verbose than usual. To be able to use
the available Maude implementations of lists and sets, I had to first
create a [[View]] that maps one of my types to the generic type
[[Elt]] used as parameter in the definition of all Maude default
structure data types.

<<alc-language.maude>>=
fmod LABEL is 
 inc ALC-SYNTAX .

 sort Label .
 subsort Role < Label .
endfm

view Label from TRIV to LABEL is 
 sort Elt to Label .
endv

@

Once I have the list of labels, I am finally ready to define the type
and constructor of labeled concepts.

<<alc-language.maude>>=
fmod LALC-SYNTAX is 
 inc LABEL .
 inc LIST{Label} .

 op s : Role List{Label} -> Label .

 vars R : Role .
 eq s(R, nil) = R .

 sorts Exp LConcept .
 subsort LConcept < Exp .

 op <_|_|_> : List{Label} Concept List{Label} -> LConcept [ctor] . 
endfm

@

We must define an auxiliar module to handle negation of concepts. We
need a function to invert and flip the list of labels of a labeled
concept. That is

<<alc-language.maude>>=
fmod LALC-AUX is 
 inc LALC-SYNTAX .
 
 sort LabelTuple .
 op [_,_] : List{Label} List{Label} -> LabelTuple [ctor] .

 op join   : List{Label} List{Label} Concept -> Concept .
 op invert : Concept -> Concept .
 op split  : List{Label} List{Label} Concept -> LabelTuple .
 op neg : List{Label} List{Label} -> LabelTuple .
 
 vars L1 L2 L : List{Label} .
 vars R S : Role .
 vars C : Concept .
 
 eq neg(L1, L2) = split(nil, nil, invert(join(L1, L2, CTRUE))) .

 eq join(L1,  s(R,L1) L2, C)   = join(L1, L2, EXIST(R,C)) .  
 eq join(nil, R L2, C)   = join(nil, L2, EXIST(R,C)) . 
 
 eq join(L1 R, L2, C) = join(L1, L2, ALL(R,C)) [owise] . 
 eq join(nil, nil, C) = C .
 
 eq invert(ALL(R, C))   = EXIST(R, invert(C)) .
 eq invert(EXIST(R, C)) = ALL(R, invert(C)) .
 eq invert(C) = C [owise] .
 
 eq split(L1, L2, ALL(R,C))   = split(L1 R, L2, C) .
 eq split(L1, L2, EXIST(R,C)) = split(L1, s(R,L1) L2, C) .
 eq split(L1, L2, C) = [L1, L2] [owise] .
 
endfm

@

Given the above definitions, we can now test if the language is well
defined. We create a test module with some atomic concepts and roles
constants to be able to write a labelled concept.

<<test-language.maude>>=
in alc-language.maude

fmod TEST is
 inc LALC-AUX .

 ops A B C D E : -> AConcept .
 ops R S T U V : -> ARole .
endfm

red < R S | ALL(R, A & ~ B) | s(V, R S) T S > . 

@ 

\subsection{The Sequent Calculus}\label{sec:alc}

We again defined a [[view]] over the [[TRIV]] module so that we can
easly define sets of labeled concepts.

<<alc-system.maude>>=
in alc-language.maude

view Exp from TRIV to LALC-SYNTAX is 
 sort Elt to Exp .
endv

@  

We are now ready to define the Sequent Calculus system. We introduce
the datatypes: [[Sequent]] and [[Goal]]. In that way, a proof is just
a multiset of goal objects. That is, a directed acyclic graph.

<<alc-system.maude>>=
mod LALC-SYSTEM is
 inc LALC-AUX .
 inc SET{Exp} .
 inc SET{Nat} .
 inc NAT . 
 inc QID .

 sort Sequent .
 op _|-_ : Set{Exp} Set{Exp} -> Sequent [ctor prec 122 gather(e e)] .

 sorts Goal State Proof .
 subsort Goal State < Proof .

 op next  : Nat -> State .
 op goals : Set{Nat} -> State .

 op [_from_by_is_] : Nat Nat Qid Sequent -> Goal [format (n d d d d d d d d d)] .
 op __ : Proof Proof -> Proof [ctor comm assoc] .
 
 vars ALFA GAMMA : Set{LConcept} .
 vars X Y N : Nat .
 var XS : Set{Nat} .
 vars A B C D : Concept .
 vars R S : Role .
 var AT : AConcept .
 var Q : Qid .
 vars L L1 L2 L3 L4 : List{Label} .

 <<SALC Initial>>
 <<SALC AND>>
 <<SALC OR>>
 <<SALC NOT>>
 <<SALC Labels>>
 <<Promotion Exist>>
 <<Promotion All>>

endm

@  

Each rule is defined as a rewriting rule envolving a sequent, the set
of goals and the counter of sequents. Let us begin with the [[init]]
rule. We will try to avoid the necessity of structural rules
considering as axiom any sequent with a common concept in both sides.

<<SALC Initial>>=
 rl [initial] : 
  [ X from Y by Q is ALFA, < nil | AT | nil > |- < nil | AT | nil >, GAMMA ] goals((X, XS)) => 
  [ X from Y by Q is ALFA, < nil | AT | nil > |- < nil | AT | nil >, GAMMA ] goals((XS)) .

@ 

The rules of proposition calculus are trivial. The [[and-r]] creates
two sequents from one given sequent:

<<SALC AND>>=
 rl [and-r] : 
  [ X from Y by Q is ALFA |- GAMMA, < L | A & B | nil > ] next(N) goals((X, XS)) => 
  [ X from Y by Q is ALFA |- GAMMA, < L | A & B | nil > ] next(N + 2) goals((XS, N, N + 1)) 
  [ N     from X by 'and-r is ALFA |- GAMMA, < L | A | nil > ] 
  [ N + 1 from X by 'and-r is ALFA |- GAMMA, < L | B | nil > ] .

 rl [and-l] : 
  [ X from Y by Q is      ALFA, < L | A & B | nil > |- GAMMA ] next(N) goals((X, XS)) => 
  [ X from Y by Q is      ALFA, < L | A & B | nil > |- GAMMA ] next(N + 1) goals((XS, N)) 
  [ N from X by 'and-l is ALFA, < L | A | nil >, < L | B | nil > |- GAMMA ] .

@ 

In the same way, the rules for the dijunction of concepts:

<<SALC OR>>=
 rl [or-l] : 
  [ X from Y by Q is  ALFA, < nil | (A | B) | L > |- GAMMA ] next(N) goals((X, XS)) =>
  [ X from Y by Q is  ALFA, < nil | (A | B) | L > |- GAMMA ] next(N + 2) goals((XS, N, N + 1))
  [ N     from X by 'or-l is  ALFA, < nil | A | L > |- GAMMA ] 
  [ N + 1 from X by 'or-l is  ALFA, < nil | B | L > |- GAMMA ] .

 rl [or-r] : 
  [ X from Y by Q is     ALFA |- GAMMA, < nil | (A | B) | L > ] next(N) goals((X, XS)) => 
  [ X from Y by Q is     ALFA |- GAMMA, < nil | (A | B) | L > ] next(N + 1) goals((XS, N))
  [ N from X by 'or-r is  ALFA |- GAMMA, < nil | A | L >, < nil | B | L > ] .

@ 

The rules for negation are a little bit more complex, we have to
invert the lists of labels to construct the negation of a labeled
concept. We use conditional rewriting rules and the function [[neg]]
defined in the functional module [[LALC-AUX]].

<<SALC NOT>>=
 crl [neg-l] : 
  [ X from Y by Q is    ALFA, < L1 | ~ A | L2 >  |- GAMMA ] next(N)  goals((X, XS)) => 
  [ X from Y by Q is    ALFA, < L1 | ~ A | L2 >  |- GAMMA ] next(N + 1) goals((XS, N))
  [ N from X by 'neg-l is ALFA |- GAMMA, < L3 | A | L4 > ] 
 if [L3, L4] := neg(L1, L2) .

 crl [neg-r] : 
  [ X from Y by Q is    ALFA |- GAMMA, < L1 | ~ A | L2 > ] next(N) goals((X, XS)) => 
  [ X from Y by Q is    ALFA |- GAMMA, < L1 | ~ A | L2 > ] next(N + 1) goals((XS, N))
  [ N from X by 'neg-r is ALFA, < L3 | A | L4 > |- GAMMA ] 
 if [L3, L4] := neg(L1, L2) .

@ 

The rules for $\forall$ and $\exists$ could be rewritten in just to
rules if we had defined the sequent as one set of pairs (concept,
side) instead of the current operator [[_|-_]] which keeps two
separated sets of concepts. We will consider such optimization in
future versions of this code.

<<SALC Labels>>=
 rl [forall-r] : 
  [ X from Y by Q is    ALFA |- GAMMA, < L1 | ALL(R, A) | L2 > ] next(N) goals((X, XS)) => 
  [ X from Y by Q is    ALFA |- GAMMA, < L1 | ALL(R, A) | L2 > ] next(N + 1) goals((XS, N))
  [ N from X by 'forall-r is   ALFA |- GAMMA, < L1 R | A | L2 > ] .

 rl [forall-l] : 
  [ X from Y by Q is    ALFA, < L1 | ALL(R, A) | L2 > |- GAMMA ] next(N) goals((X, XS)) => 
  [ X from Y by Q is    ALFA, < L1 | ALL(R, A) | L2 > |- GAMMA ] next(N + 1) goals((XS, N)) 
  [ N from X by 'forall-l is  ALFA, < L1 R | A | L2 > |- GAMMA ] .

 rl [exist-r] : 
  [ X from Y by Q is    ALFA |- GAMMA, < L1 | EXIST(R, A) | L2 > ] next(N) goals((X, XS)) => 
  [ X from Y by Q is    ALFA |- GAMMA, < L1 | EXIST(R, A) | L2 > ] next(N + 1) goals((XS, N)) 
  [ N from X by 'exist-r is ALFA |- GAMMA, < L1 | A | s(R, L1) L2 > ] .

 rl [exist-l] : 
  [ X from Y by Q is    ALFA, < L1 | EXIST(R, A) | L2 > |- GAMMA ] next(N) goals((X, XS)) => 
  [ X from Y by Q is    ALFA, < L1 | EXIST(R, A) | L2 > |- GAMMA ] next(N + 1) goals((XS, N))
  [ N from X by 'exist-l is   ALFA, < L1 | A | s(R, L1) L2 > |- GAMMA ] .

@

The promotion rules require a elaborated implementation since they
operate not only in a single concept but on the sequent as a whole.

<<Promotion Exist>>=
 vars LA LB : LConcept .
 var GAMMA' ALFA' : Set{LConcept} .
 
 op all-label-exist        : Set{LConcept} Label -> Bool .
 op remove-label-exist     : Set{LConcept} Label -> Set{LConcept} .
 op remove-label-exist-aux : Set{LConcept} Label Set{LConcept} -> Set{LConcept} .
 
 ceq all-label-exist((LA, GAMMA), R) = all-label-exist(GAMMA, R)
  if < L1 | A | L2 R > := LA .
  
 eq all-label-exist(empty, R) = true . 
 eq all-label-exist(GAMMA, R) = false [owise] .
 
 eq remove-label-exist(GAMMA, R) = 
    remove-label-exist-aux(GAMMA, R, empty) .
    
 eq remove-label-exist-aux((< L1 | A | L2 R >, GAMMA), R, GAMMA') = 
    remove-label-exist-aux(GAMMA, R, (GAMMA', < L1 | A | L2 >)) .

 eq remove-label-exist-aux(empty, R, GAMMA) = GAMMA .
    
 crl [prom-exist] : 
  [ X from Y by Q is    < L1 | A | L2 R > |- GAMMA ] next(N)     goals((X, XS)) => 
  [ X from Y by Q is    < L1 | A | L2 R > |- GAMMA ] next(N + 1) goals((XS, N))
  [ N from X by 'prom-exist is  < L1 | A | L2 > |- GAMMA' ] 
 if all-label-exist(GAMMA, R) = true /\ GAMMA' := remove-label-exist(GAMMA, R) .

@ 

The [[prom-all]] and [[prom-all-esp]] rules are defined in a similar way:

<<Promotion All>>=
 op all-label-all        : Set{LConcept} Label -> Bool .
 op remove-label-all     : Set{LConcept} Label -> Set{LConcept} .
 op remove-label-all-aux : Set{LConcept} Label Set{LConcept} -> Set{LConcept} .
 
 ceq all-label-all((LA, ALFA), R) = all-label-exist(ALFA, R)
  if < R L L1 | A | L2 s(S, R L) > := LA .
  
 ceq all-label-all((LA, ALFA), R) = all-label-exist(ALFA, R)
  if < R L1 | A | nil > := LA .

 eq all-label-all(empty, R) = true . 
 eq all-label-all(ALFA, R) = false [owise] .
 
 eq remove-label-all(ALFA, R) = 
    remove-label-all-aux(ALFA, R, empty) .
    
 eq remove-label-all-aux((< R L1 | A | nil >, ALFA), R, ALFA') = 
    remove-label-all-aux(ALFA, R, (ALFA', < L1 | A | nil >)) .

 eq remove-label-all-aux((< R L L1 | A | L2 s(S, R L) >, ALFA), R, ALFA') = 
    remove-label-all-aux(ALFA, R, (ALFA', < L L1 | A | L2 s(S, L) >)) .
    
 eq remove-label-all-aux(empty, R, ALFA) = ALFA .
    
 crl [prom-all-esp] : 
  [ X from Y by Q is    ALFA |- < R L1 | A | nil > ] next(N)     goals((X, XS)) => 
  [ X from Y by Q is    ALFA |- < R L1 | A | nil > ] next(N + 1) goals((XS, N))
  [ N from X by 'prom-all-esp is  ALFA' |- < L1 | A | nil >  ] 
 if all-label-all(ALFA, R) = true /\ ALFA' := remove-label-all(ALFA, R) .

 crl [prom-all] : 
  [ X from Y by Q is    ALFA |- < R L L1 | A | L2 s(S, R L) > ] next(N)     goals((X, XS)) => 
  [ X from Y by Q is    ALFA |- < R L L1 | A | L2 s(S, R L) > ] next(N + 1) goals((XS, N))
  [ N from X by 'prom-all is  ALFA' |- < L1 | A | L2 s(S, L) >  ] 
 if all-label-all(ALFA, R) = true /\ ALFA' := remove-label-all(ALFA, R) .
 
@ 

\subsection{Testing}

For testing, we create a theory that actually can be viewed as an ontology instantiation. 

<<test-alc-system.maude>>=
in alc-system.maude 

mod TEST-SYSTEM is
 inc LALC-SYSTEM .

 <<Test Cases>>
endm

@

Where the test cases are the following:

<<Test Cases>>=
 ops A B C D E : -> AConcept .
 ops R S T U V : -> ARole .

 ops seq : Nat -> Sequent .
 eq seq(1) = < nil | EXIST(S, ALL(R, A)) | nil > |- < nil | EXIST(S, ALL(R, A)) | nil > .
 eq seq(2) = < nil | ALL(S, EXIST(R, A)) | nil > |- < nil | ALL(S, EXIST(R, A)) | nil > .
 eq seq(3) = < nil | EXIST(R, CTRUE) & ALL(R, ~ EXIST(R, ~ A)) | nil > |- < nil | EXIST(R, ALL(R, A)) | nil > .
 eq seq(4) = < nil | A & B | nil > |- < nil | (A | B) | nil > .
 eq seq(5) = < R | A & B | S > |- < R | (A | B) | S > .
 eq seq(6) = < S | A & B | R >, < R | A & B | S > |- < R | (A | B) | S >, < S | (A | B) | R > . 
 eq seq(7) = < R | A | B | S > |- < R | (A & B) | S > .
 
 op start : Sequent -> Goal . 
 eq start(X:Sequent) = [ 0 from 0 by 'init is X:Sequent ] next(1) goals(0) .
 
@

We can test the system asking for one possible derivation tree for the
first sequent:

\begin{verbatim}
Maude> rew start(seq(1)) .
result Proof: next(7) goals(empty) 
[0 from 0 by 'init is < nil | EXIST(S, ALL(R, A)) | nil > |- < nil | EXIST(S, ALL(R, A)) | nil >] 
[1 from 0 by 'exist-r is < nil | EXIST(S, ALL(R, A)) | nil > |- < nil | ALL(R, A) | S >] 
[2 from 1 by 'exist-l is < nil | ALL(R, A) | S > |- < nil | ALL(R, A) | S >] 
[3 from 2 by 'prom-exist is < nil | ALL(R, A) | nil > |- < nil | ALL(R, A) | nil >] 
[4 from 3 by 'forall-r is < nil | ALL(R, A) | nil > |- < R | A | nil >] 
[5 from 4 by 'forall-l is < R | A | nil > |- < R | A | nil >] 
[6 from 5 by 'prom-all-esp is < nil | A | nil > |- < nil | A | nil >]
\end{verbatim}

Moreover, one can check how possible derivation trees exist for such
sequent:

\begin{verbatim}
Maude> search start(seq(1)) =>! P:Proof .
[...]
Solution 16 (state 78)
[...]
No more solutions.
\end{verbatim}

\begin{verbatim}
Maude> search start(seq(1)) =>! P:Proof goals(S:Set{Nat}) 
       such that S:Set{Nat} =/= empty .

No solution.
\end{verbatim}

The problem with the system defined so far is that the structural
rules cannot be omitted. We avoided the necessity of permutation rules
defining sequents as two sets of formulas instead of two lists of
formulas. But the weakness rules cannot be omitted as we show in the
command below. The sequent [[seq3]] above is a tautology, that is, it
should be possible to obtain a proof (proof state with empty goals) of
it.

\begin{verbatim}
Maude> search start(seq(3)) =>! P:Proof goals(empty) .

No solution.
\end{verbatim}

We can search for full expanded derivation trees to identify why
weakness rules are necessary. For instance, consider the last possible
derivation tree returned by the command below. We can see that in the
state 9 the absence of weakness rules block the application of
[[prom-all-esp]] rule.

\begin{verbatim}
Maude> search start(seq(3)) =>! P:Proof .

Solution 362 (state 1035)
P:Proof --> next(10) goals(9) 
[0 from 0 by 'init is < nil | EXIST(R, CTRUE) & ALL(R, ~ EXIST(R, ~ A)) | nil > 
  |- < nil | EXIST(R, ALL(R, A)) | nil >] 
[1 from 0 by 'exist-r is < nil | EXIST(R, CTRUE) & ALL(R, ~ EXIST(R, ~ A)) | nil > 
  |- < nil | ALL(R, A) | R >] 
[2 from 1 by 'forall-r is < nil | EXIST(R, CTRUE) & ALL(R, ~ EXIST(R, ~ A)) | nil > 
  |- < R | A | R >] 
[3 from 2 by 'and-l is < nil | ALL(R, ~ EXIST(R, ~ A)) | nil >, 
  < nil | EXIST(R, CTRUE) | nil > |- < R | A | R >] 
[4 from 3 by 'exist-l is < nil | CTRUE | R >, 
  < nil | ALL(R, ~ EXIST(R, ~ A)) | nil > |- < R | A | R >] 
[5 from 4 by 'forall-l is < nil | CTRUE | R >, 
  < R | ~ EXIST(R, ~ A) | nil > |- < R | A | R >] 
[6 from 5 by 'neg-l is < nil | CTRUE | R > |- 
  < nil | EXIST(R, ~ A) | R >, < R | A | R >] 
[7 from 6 by 'prom-exist is < nil | CTRUE | nil > |- 
  < nil | EXIST(R, ~ A) | nil >, < R | A | nil >] 
[8 from 7 by 'exist-r is < nil | CTRUE | nil > |- < nil | ~ A | R >, < R | A | nil >] 
[9 from 8 by 'neg-r is < nil | CTRUE | nil >, < R | A | nil > |- < R | A | nil >]

No more solutions.
\end{verbatim}

Of course, there is another possible solution for this particular case
rather than the introduction of weakness rules. We could redefine the
[[init]] rule to consider as axioms not only atomic concepts without
labels but also a general labeled concept occuring in both sides of
the sequent. Nevertheless, this solution is not sufficient. Consider
the set of sentences $\mathcal{T} = \{ A \subs B, A' \subs B' \}$,
it is clear that $\mathcal{T} \models A \dland A' \subs B \dlor B'$ but the command
below fails to find a proof for that logical consequence:

\begin{verbatim}
Maude> search start(seq(6)) =>! P:Proof .

Solution 1 (state 0)
states: 1  rewrites: 2 in 0ms cpu (0ms real) (3780 rewrites/second)
P:Proof --> next(1) goals(0) 
[0 from 0 by 'init is < R | A & B | S >, < S | A & B | R > |- < R | A | B | S >, < S | A | B | R >]

No more solutions.
\end{verbatim}


\subsection{Fixing the System}

Let us introduce the weakness rules in the system:

<<alc-system.maude>>=
mod LALC-SYSTEM-FULL is 
 inc LALC-SYSTEM .

 vars ALFA GAMMA : Set{LConcept} .
 vars X Y N : Nat .
 var XS : Set{Nat} .
 var F : LConcept .
 var Q : Qid .
 
 rl [weak-l] : 
  [ X from Y by Q is      ALFA, F |- GAMMA ] next(N) goals((X, XS)) => 
  [ X from Y by Q is      ALFA, F |- GAMMA ] next(N + 1) goals((XS, N)) 
  [ N from X by 'weak-l is ALFA |- GAMMA ] .

 rl [weak-r] : 
  [ X from Y by Q is      ALFA |- GAMMA, F ] next(N) goals((X, XS)) => 
  [ X from Y by Q is      ALFA |- GAMMA, F ] next(N + 1) goals((XS, N)) 
  [ N from X by 'weak-r is ALFA |- GAMMA ] .
  
endm  

@ 

We will use the same test cases presented previously. We finally
present the module [[TEST-SYSTEM-FULL]] below:

<<test-alc-system.maude>>=

mod TEST-SYSTEM-FULL is
 inc LALC-SYSTEM-FULL .

 <<Test Cases>>
endm

@

\section{The Deterministic System}\label{sec:alcb}

The system presented in Section~\label{sec:deterministic-system} is a
non-deterministic system. That is, given a tautology, one can still
fail to find a proof for it if a wrong sequent of rule application is
choosen.

Let us introduce a deterministic version of the system. The system is
presented in \cite{sbia}.

<<alc-bracked-system>>=
in alc-language.maude

fmod ALC-LANGUAGE-FROZEN is
 inc LALC-SYNTAX .
 inc NAT .

 sort FzConcept .
 subsort FzConcept < Exp .

 op frozen : Nat LConcept -> FzConcept .
 
endfm

@





\section{Conclusion}

Todo.

\appendix

\section{The pretty print module}

<<alc-latex.maude>>=
in alc-language.maude 

fmod LATEX is 
 inc LALC-SYNTAX .
 inc STRING .
 
 op latex : Concept -> String .
 op latex : Role -> String .
 
 vars A B C : Concept .
 var R : Role .
 vars L1 L2 : List{Label} .

 eq latex(CTRUE) = "\top" .
 eq latex(CFALSE) = "\bot" .
 
 eq latex( ~ A )   = "\neg (" + latex(A) + ")" .
 eq latex( A | B ) = "(" + latex(A) + " /dlor "  + latex(B) + ")" .
 eq latex( A & B ) = "(" + latex(A) + " /dland " + latex(B) + ")" .
 eq latex( ALL(R,A) ) =   "\forall " + latex(R) + ". (" + latex(A) + ")" .
 eq latex( EXIST(R,A) ) = "/exists " + latex(R) + ". (" + latex(A) + ")" .

 op latex : List{Label} -> String .
 
 eq latex(s(R, L1) L2) = latex(R) + "(" + latex(L1) + ") " + latex(L2) .
 eq latex(R L1) = latex(R) + " " + latex(L1) .
 eq latex(nil)  = "" .
 
 op latex : LConcept -> String .

 eq latex(< L1 | A | L2 >) = "/lc{" + latex(L1) + "}{" + latex(A) + "}{" + latex(L2) + "}" .

endfm

fmod LATEX-TEST is
 inc LATEX .
 inc QID .
 
 
 op conc : Qid -> AConcept .
 op role : Qid -> ARole .

 var Q : Qid .
 
 eq latex(conc(Q)) = string(Q) .
 eq latex(role(Q)) = string(Q) .
 
 ops c1 c2 : -> Concept .
 
 eq c1 =   ALL(role('R), conc('A) & CTRUE) .
 eq c2 = EXIST(role('R), conc('A) | CTRUE) .
 
 op c3 : -> LConcept .
 eq c3 = < role('R) role('S) | ~ conc('A) | s(role('X), role('S)) role('R)  > .

endfm 
 
@ 

\end{document}
