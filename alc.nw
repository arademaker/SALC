
\title{A naive implementation of a Sequent Calculus for $\mathcal{ALC}$ in Maude}
\author{Alexandre Rademaker}
\maketitle

\begin{abstract} 
  This is an exercise about how could be an implementation of a
  sequent calculos in Maude. Maude most used features here are pattern
  matching for definition of functions, data and program as terms, the
  easy way to implement ``possible proofs'' using rules, search and
  rewrites.
\end{abstract}


\section{Introduction}

The main motivation to implement the system described here is my need
to exercise the deduction system $S_{\mathcal{ALC}}$.

\section{The Implementation}

The first step was to implement the language. If I was thinking about
a generic theorem prover, I would have started from the common
infrastructure for a sequent calculus reasoner. However, since my
purpose was to archive my results quickly, I choose to start from the
language definition.

<<alc-language.maude>>=
fmod ALC-SYNTAX is 
 sorts AConcept Concept ARole Role .
 subsort AConcept < Concept .
 subsort ARole < Role .

 ops ALL EXIST : Role Concept -> Concept .
 ops CTRUE CFALSE : -> Concept .
 op _&_ : Concept Concept -> Concept [gather (e E) prec 31] .
 op _|_ : Concept Concept -> Concept [gather (e E) prec 32] .
 op ~_  : Concept -> Concept [prec 30] .
endfm

@ 

The system is a labeled sequent calculus. So that, we had actually to
deal with two different languages. The first one, the traditional
$\mathcal{ALC}$. The second one, the extended syntax to labels. Since
Maude as developed for formal analysis and verification, based in a
well studied formalism called Rewriting Logic, its support for modular
specification is more formal and verbose than usual. To be able to use
the available Maude implementations of lists and sets, I had to first
create a [[View]] that maps one of my types to the generic type
[[Elt]] used as parameter in the definition of all Maude default
structure data types.

<<alc-language.maude>>=
fmod LABEL is 
 inc ALC-SYNTAX .

 sort Label .
 subsort Role < Label .
endfm

view Label from TRIV to LABEL is 
 sort Elt to Label .
endv

@

Once I have the list of labels, I am finally ready to define the type
and constructor of labeled concepts.

<<alc-language.maude>>=
fmod LALC-SYNTAX is 
 inc LABEL .
 inc LIST{Label} .

 op s : Role List{Label} -> Label .

 vars R : Role .
 eq s(R, nil) = R .

 sort LConcept .
 op <_|_|_> : List{Label} Concept List{Label} -> LConcept [ctor] . 
endfm

@

We must define an auxiliar module to handle negation of concepts. We
need a function to invert and flip the list of labels of a labeled
concept. That is

<<alc-language.maude>>=
fmod LALC-AUX is 
 inc LALC-SYNTAX .
 
 sort LabelTuple .
 op [_,_] : List{Label} List{Label} -> LabelTuple [ctor] .

 op join   : List{Label} List{Label} Concept -> Concept .
 op invert : Concept -> Concept .
 op split  : List{Label} List{Label} Concept -> LabelTuple .
 op neg : List{Label} List{Label} -> LabelTuple .
 
 vars L1 L2 L : List{Label} .
 vars R S : Role .
 vars C : Concept .
 
 eq neg(L1, L2) = split(nil, nil, invert(join(L1, L2, CTRUE))) .

 eq join(L1,  s(R,L1) L2, C)   = join(L1, L2, EXIST(R,C)) .  
 eq join(nil, R L2, C)   = join(nil, L2, EXIST(R,C)) . 
 
 eq join(L1 R, L2, C) = join(L1, L2, ALL(R,C)) [owise] . 
 eq join(nil, nil, C) = C .
 
 eq invert(ALL(R, C))   = EXIST(R, invert(C)) .
 eq invert(EXIST(R, C)) = ALL(R, invert(C)) .
 eq invert(C) = C [owise] .
 
 eq split(L1, L2, ALL(R,C))   = split(L1 R, L2, C) .
 eq split(L1, L2, EXIST(R,C)) = split(L1, s(R,L1) L2, C) .
 eq split(L1, L2, C) = [L1, L2] [owise] .
 
endfm

@

Given the above definitions, we can now test if the language is well
defined. We create a test module with some atomic concepts and roles
constants to be able to write a labelled concept.

<<test-language.maude>>=
in alc-language.maude

fmod TEST is
 inc LALC-AUX .

 ops A B C D E : -> AConcept .
 ops R S T U V : -> ARole .
endfm

red < R S | ALL(R, A & ~ B) | s(V, R S) T S > . 

@ 

\subsection{The Sequent Calculus}

We again defined a [[view]] over the [[TRIV]] module so that we can
easly define sets of labeled concepts.

<<alc-system.maude>>=
in alc-language.maude

view LConcept from TRIV to LALC-SYNTAX is 
 sort Elt to LConcept .
endv

@  

We are now ready to define the Sequent Calculus system. We introduce
the datatypes: [[Sequent]] and [[Goal]]. In that way, a proof is just
a multiset of goal objects. That is, a directed acyclic graph.

<<alc-system.maude>>=
mod SEQUENT-CALCULUS is
 inc LALC-AUX .
 inc SET{LConcept} .
 inc SET{Nat} .
 inc NAT . 
 inc QID .

 sort Sequent .
 op _|-_ : Set{LConcept} Set{LConcept} -> Sequent [ctor prec 122 gather(e e)] .

 sorts Goal State Proof .
 subsort Goal State < Proof .

 op next  : Nat -> State .
 op goals : Set{Nat} -> State .

 op [_from_by_is_] : Nat Nat Qid Sequent -> Goal [format (n d d d d d d d d d)] .
 op __ : Proof Proof -> Proof [ctor comm assoc] .

 vars ALFA GAMMA : Set{LConcept} .
 vars X Y N : Nat .
 var XS : Set{Nat} .
 vars A B C D : Concept .
 vars R S : Role .
 var AT : AConcept .
 var Q : Qid .
 vars L L1 L2 L3 L4 : List{Label} .

 rl [initial] : 
  [ X from Y by Q is ALFA, < nil | AT | nil > |- < nil | AT | nil >, GAMMA ] goals((X, XS)) => 
  [ X from Y by Q is ALFA, < nil | AT | nil > |- < nil | AT | nil >, GAMMA ] goals((XS)) .

 rl [and-r] : 
  [ X from Y by Q is ALFA |- GAMMA, < L | A & B | nil > ] next(N) goals((X, XS)) => 
  [ X from Y by Q is ALFA |- GAMMA, < L | A & B | nil > ] next(N + 2) goals((XS, N, N + 1)) 
  [ N     from X by 'and-r is ALFA |- GAMMA, < L | A | nil > ] 
  [ N + 1 from X by 'and-r is ALFA |- GAMMA, < L | B | nil > ] .

 rl [and-l] : 
  [ X from Y by Q is      ALFA, < L | A & B | nil > |- GAMMA ] next(N) goals((X, XS)) => 
  [ X from Y by Q is      ALFA, < L | A & B | nil > |- GAMMA ] next(N + 1) goals((XS, N)) 
  [ N from X by 'and-l is ALFA, < L | A | nil >, < L | B | nil > |- GAMMA ] .

 rl [or-l] : 
  [ X from Y by Q is  ALFA, < nil | (A | B) | L > |- GAMMA ] next(N) goals((X, XS)) =>
  [ X from Y by Q is  ALFA, < nil | (A | B) | L > |- GAMMA ] next(N + 2) goals((XS, N, N + 1))
  [ N     from X by 'or-l is  ALFA, < nil | A | L > |- GAMMA ] 
  [ N + 1 from X by 'or-l is  ALFA, < nil | B | L > |- GAMMA ] .

 rl [or-r] : 
  [ X from Y by Q is     ALFA |- GAMMA, < nil | (A | B) | L > ] next(N) goals((X, XS)) => 
  [ X from Y by Q is     ALFA |- GAMMA, < nil | (A | B) | L > ] next(N + 1) goals((XS, N))
  [ N from X by 'or-r is  ALFA |- GAMMA, < nil | A | L >, < nil | B | L > ] .

 rl [forall-r] : 
  [ X from Y by Q is    ALFA |- GAMMA, < L1 | ALL(R, A) | L2 > ] next(N) goals((X, XS)) => 
  [ X from Y by Q is    ALFA |- GAMMA, < L1 | ALL(R, A) | L2 > ] next(N + 1) goals((XS, N))
  [ N from X by 'forall-r is   ALFA |- GAMMA, < L1 R | A | L2 > ] .

 rl [forall-l] : 
  [ X from Y by Q is         ALFA, < L1 | ALL(R, A) | L2 > |- GAMMA ] next(N) goals((X, XS)) => 
  [ X from Y by Q is         ALFA, < L1 | ALL(R, A) | L2 > |- GAMMA ] next(N + 1) goals((XS, N)) 
  [ N from X by 'forall-l is  ALFA, < L1 R | A | L2 > |- GAMMA ] .

 rl [exist-r] : 
  [ X from Y by Q is       ALFA |- GAMMA, < L1 | EXIST(R, A) | L2 > ] next(N) goals((X, XS)) => 
  [ X from Y by Q is       ALFA |- GAMMA, < L1 | EXIST(R, A) | L2 > ] next(N + 1) goals((XS, N)) 
  [ N from X by 'exist-r is ALFA |- GAMMA, < L1 | A | s(R, L1) L2 > ] .

 rl [exist-l] : 
  [ X from Y by Q is      ALFA, < L1 | EXIST(R, A) | L2 > |- GAMMA ] next(N) goals((X, XS)) => 
  [ X from Y by Q is      ALFA, < L1 | EXIST(R, A) | L2 > |- GAMMA ] next(N + 1) goals((XS, N))
  [ N from X by 'exist-l is   ALFA, < L1 | A | s(R, L1) L2 > |- GAMMA ] .

 crl [neg-l] : 
  [ X from Y by Q is    ALFA, < L1 | ~ A | L2 >  |- GAMMA ] next(N)  goals((X, XS)) => 
  [ X from Y by Q is    ALFA, < L1 | ~ A | L2 >  |- GAMMA ] next(N + 1) goals((XS, N))
  [ N from X by 'neg-l is ALFA |- GAMMA, < L3 | A | L4 > ] 
 if [L3, L4] := neg(L1, L2) .

 crl [neg-r] : 
  [ X from Y by Q is    ALFA |- GAMMA, < L1 | ~ A | L2 > ] next(N) goals((X, XS)) => 
  [ X from Y by Q is    ALFA |- GAMMA, < L1 | ~ A | L2 > ] next(N + 1) goals((XS, N))
  [ N from X by 'neg-r is ALFA, < L3 | A | L4 > |- GAMMA ] 
 if [L3, L4] := neg(L1, L2) .

<<Promotion Exist>>
<<Promotion All>>

endm

@

The promotion rules require a bit more complex implementation since
they operate not only in a single concept but on the sequent as a
whole.

<<Promotion Exist>>=
 vars LA LB : LConcept .
 var GAMMA' ALFA' : Set{LConcept} .
 
 op all-label-exist        : Set{LConcept} Label -> Bool .
 op remove-label-exist     : Set{LConcept} Label -> Set{LConcept} .
 op remove-label-exist-aux : Set{LConcept} Label Set{LConcept} -> Set{LConcept} .
 
 ceq all-label-exist((LA, GAMMA), R) = all-label-exist(GAMMA, R)
  if < L1 | A | L2 R > := LA .
  
 eq all-label-exist(empty, R) = true . 
 eq all-label-exist(GAMMA, R) = false [owise] .
 
 eq remove-label-exist(GAMMA, R) = 
    remove-label-exist-aux(GAMMA, R, empty) .
    
 eq remove-label-exist-aux((< L1 | A | L2 R >, GAMMA), R, GAMMA') = 
    remove-label-exist-aux(GAMMA, R, (GAMMA', < L1 | A | L2 >)) .

 eq remove-label-exist-aux(empty, R, GAMMA) = GAMMA .
    
 crl [prom-exist] : 
  [ X from Y by Q is    < L1 | A | L2 R > |- GAMMA ] next(N)     goals((X, XS)) => 
  [ X from Y by Q is    < L1 | A | L2 R > |- GAMMA ] next(N + 1) goals((XS, N))
  [ N from X by 'prom-exist is  < L1 | A | L2 > |- GAMMA' ] 
 if all-label-exist(GAMMA, R) = true /\ GAMMA' := remove-label-exist(GAMMA, R) .

@ 

The [[prom-all]] and [[prom-all-esp]] rules are defined in a similar way:

<<Promotion All>>=
 op all-label-all        : Set{LConcept} Label -> Bool .
 op remove-label-all     : Set{LConcept} Label -> Set{LConcept} .
 op remove-label-all-aux : Set{LConcept} Label Set{LConcept} -> Set{LConcept} .
 
 ceq all-label-all((LA, ALFA), R) = all-label-exist(ALFA, R)
  if < R L L1 | A | L2 s(S, R L) > := LA .
  
 ceq all-label-all((LA, ALFA), R) = all-label-exist(ALFA, R)
  if < R L1 | A | nil > := LA .

 eq all-label-all(empty, R) = true . 
 eq all-label-all(ALFA, R) = false [owise] .
 
 eq remove-label-all(ALFA, R) = 
    remove-label-all-aux(ALFA, R, empty) .
    
 eq remove-label-all-aux((< R L1 | A | nil >, ALFA), R, ALFA') = 
    remove-label-all-aux(ALFA, R, (ALFA', < L1 | A | nil >)) .

 eq remove-label-all-aux((< R L L1 | A | L2 s(S, R L) >, ALFA), R, ALFA') = 
    remove-label-all-aux(ALFA, R, (ALFA', < L L1 | A | L2 s(S, L) >)) .
    
 eq remove-label-all-aux(empty, R, ALFA) = ALFA .
    
 crl [prom-all-esp] : 
  [ X from Y by Q is    ALFA |- < R L1 | A | nil > ] next(N)     goals((X, XS)) => 
  [ X from Y by Q is    ALFA |- < R L1 | A | nil > ] next(N + 1) goals((XS, N))
  [ N from X by 'prom-all-esp is  ALFA' |- < L1 | A | nil >  ] 
 if all-label-all(ALFA, R) = true /\ ALFA' := remove-label-all(ALFA, R) .

 crl [prom-all] : 
  [ X from Y by Q is    ALFA |- < R L L1 | A | L2 s(S, R L) > ] next(N)     goals((X, XS)) => 
  [ X from Y by Q is    ALFA |- < R L L1 | A | L2 s(S, R L) > ] next(N + 1) goals((XS, N))
  [ N from X by 'prom-all is  ALFA' |- < L1 | A | L2 s(S, L) >  ] 
 if all-label-all(ALFA, R) = true /\ ALFA' := remove-label-all(ALFA, R) .
 
@ 

\section{Testing}

For testing, we create a theory that actually can be viewed as an ontology instantiation. 

<<test-system.maude>>=
in alc-system.maude 

mod TEST is
 inc SEQUENT-CALCULUS .

 ops A B C D E : -> AConcept .
 ops R S T U V : -> ARole .

 ops seq1 seq2 seq3 : -> Sequent .
 eq seq1 = < nil | EXIST(S, ALL(R, A)) | nil > |- < nil | EXIST(S, ALL(R, A)) | nil > .
 eq seq2 = < nil | ALL(S, EXIST(R, A)) | nil > |- < nil | ALL(S, EXIST(R, A)) | nil > .

 eq seq3 = < nil | EXIST(R, CTRUE) & ALL(R, ~ EXIST(R, ~ A)) | nil > |- < nil | EXIST(R, ALL(R, A)) | nil > .

 ops init1 init2 init3 : -> Goal .
 eq init1 = [ 0 from 0 by 'init is seq1 ] next(1) goals(0) .
 eq init2 = [ 0 from 0 by 'init is seq2 ] next(1) goals(0) .
 
 eq init3 = [ 0 from 0 by 'init is seq3 ] next(1) goals(0) .
endm

--- set show command off .
--- rew init .
--- search init2 =>! P:Proof goals(empty) .

@


\section{Conclusion}

Todo.

